/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smoothscroll-polyfill";
exports.ids = ["vendor-chunks/smoothscroll-polyfill"];
exports.modules = {

/***/ "(ssr)/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/smoothscroll-polyfill/dist/smoothscroll.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */ (function() {\n    \"use strict\";\n    // polyfill\n    function polyfill() {\n        // aliases\n        var w = window;\n        var d = document;\n        // return if scroll behavior is supported and polyfill is not forced\n        if (\"scrollBehavior\" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n            return;\n        }\n        // globals\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468;\n        // object gathering original scroll methods\n        var original = {\n            scroll: w.scroll || w.scrollTo,\n            scrollBy: w.scrollBy,\n            elementScroll: Element.prototype.scroll || scrollElement,\n            scrollIntoView: Element.prototype.scrollIntoView\n        };\n        // define timing method\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */ function isMicrosoftBrowser(userAgent) {\n            var userAgentPatterns = [\n                \"MSIE \",\n                \"Trident/\",\n                \"Edge/\"\n            ];\n            return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\n        }\n        /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */ var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */ function scrollElement(x, y) {\n            this.scrollLeft = x;\n            this.scrollTop = y;\n        }\n        /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */ function ease(k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */ function shouldBailOut(firstArg) {\n            if (firstArg === null || typeof firstArg !== \"object\" || firstArg.behavior === undefined || firstArg.behavior === \"auto\" || firstArg.behavior === \"instant\") {\n                // first argument is not an object/null\n                // or behavior is auto, instant or undefined\n                return true;\n            }\n            if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\n                // first argument is an object and behavior is smooth\n                return false;\n            }\n            // throw error when behavior is not supported\n            throw new TypeError(\"behavior member of ScrollOptions \" + firstArg.behavior + \" is not a valid value for enumeration ScrollBehavior.\");\n        }\n        /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function hasScrollableSpace(el, axis) {\n            if (axis === \"Y\") {\n                return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n            }\n            if (axis === \"X\") {\n                return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n            }\n        }\n        /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function canOverflow(el, axis) {\n            var overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\n            return overflowValue === \"auto\" || overflowValue === \"scroll\";\n        }\n        /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function isScrollable(el) {\n            var isScrollableY = hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\n            var isScrollableX = hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\n            return isScrollableY || isScrollableX;\n        }\n        /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */ function findScrollableParent(el) {\n            while(el !== d.body && isScrollable(el) === false){\n                el = el.parentNode || el.host;\n            }\n            return el;\n        }\n        /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */ function step(context) {\n            var time = now();\n            var value;\n            var currentX;\n            var currentY;\n            var elapsed = (time - context.startTime) / SCROLL_TIME;\n            // avoid elapsed times higher than one\n            elapsed = elapsed > 1 ? 1 : elapsed;\n            // apply easing to elapsed time\n            value = ease(elapsed);\n            currentX = context.startX + (context.x - context.startX) * value;\n            currentY = context.startY + (context.y - context.startY) * value;\n            context.method.call(context.scrollable, currentX, currentY);\n            // scroll more if we have not reached our destination\n            if (currentX !== context.x || currentY !== context.y) {\n                w.requestAnimationFrame(step.bind(w, context));\n            }\n        }\n        /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */ function smoothScroll(el, x, y) {\n            var scrollable;\n            var startX;\n            var startY;\n            var method;\n            var startTime = now();\n            // define scroll context\n            if (el === d.body) {\n                scrollable = w;\n                startX = w.scrollX || w.pageXOffset;\n                startY = w.scrollY || w.pageYOffset;\n                method = original.scroll;\n            } else {\n                scrollable = el;\n                startX = el.scrollLeft;\n                startY = el.scrollTop;\n                method = scrollElement;\n            }\n            // scroll looping over a frame\n            step({\n                scrollable: scrollable,\n                method: method,\n                startTime: startTime,\n                startX: startX,\n                startY: startY,\n                x: x,\n                y: y\n            });\n        }\n        // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n        w.scroll = w.scrollTo = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n                arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n                return;\n            }\n            // LET THE SMOOTHNESS BEGIN!\n            smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        };\n        // w.scrollBy\n        w.scrollBy = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0])) {\n                original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n                return;\n            }\n            // LET THE SMOOTHNESS BEGIN!\n            smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        };\n        // Element.prototype.scroll and Element.prototype.scrollTo\n        Element.prototype.scroll = Element.prototype.scrollTo = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                // if one number is passed, throw error to match Firefox implementation\n                if (typeof arguments[0] === \"number\" && arguments[1] === undefined) {\n                    throw new SyntaxError(\"Value could not be converted\");\n                }\n                original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n                arguments[0].left !== undefined ? ~~arguments[0].left : typeof arguments[0] !== \"object\" ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n                arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n                return;\n            }\n            var left = arguments[0].left;\n            var top = arguments[0].top;\n            // LET THE SMOOTHNESS BEGIN!\n            smoothScroll.call(this, this, typeof left === \"undefined\" ? this.scrollLeft : ~~left, typeof top === \"undefined\" ? this.scrollTop : ~~top);\n        };\n        // Element.prototype.scrollBy\n        Element.prototype.scrollBy = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n                return;\n            }\n            this.scroll({\n                left: ~~arguments[0].left + this.scrollLeft,\n                top: ~~arguments[0].top + this.scrollTop,\n                behavior: arguments[0].behavior\n            });\n        };\n        // Element.prototype.scrollIntoView\n        Element.prototype.scrollIntoView = function() {\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n                return;\n            }\n            // LET THE SMOOTHNESS BEGIN!\n            var scrollableParent = findScrollableParent(this);\n            var parentRects = scrollableParent.getBoundingClientRect();\n            var clientRects = this.getBoundingClientRect();\n            if (scrollableParent !== d.body) {\n                // reveal element inside parent\n                smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);\n                // reveal parent in viewport unless is fixed\n                if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\n                    w.scrollBy({\n                        left: parentRects.left,\n                        top: parentRects.top,\n                        behavior: \"smooth\"\n                    });\n                }\n            } else {\n                // reveal element in viewport\n                w.scrollBy({\n                    left: clientRects.left,\n                    top: clientRects.top,\n                    behavior: \"smooth\"\n                });\n            }\n        };\n    }\n    if (true) {\n        // commonjs\n        module.exports = {\n            polyfill: polyfill\n        };\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRixHQUNoRjtJQUNDO0lBRUEsV0FBVztJQUNYLFNBQVNBO1FBQ1AsVUFBVTtRQUNWLElBQUlDLElBQUlDO1FBQ1IsSUFBSUMsSUFBSUM7UUFFUixvRUFBb0U7UUFDcEUsSUFDRSxvQkFBb0JELEVBQUVFLGVBQWUsQ0FBQ0MsS0FBSyxJQUMzQ0wsRUFBRU0sNkJBQTZCLEtBQUssTUFDcEM7WUFDQTtRQUNGO1FBRUEsVUFBVTtRQUNWLElBQUlDLFVBQVVQLEVBQUVRLFdBQVcsSUFBSVIsRUFBRU8sT0FBTztRQUN4QyxJQUFJRSxjQUFjO1FBRWxCLDJDQUEyQztRQUMzQyxJQUFJQyxXQUFXO1lBQ2JDLFFBQVFYLEVBQUVXLE1BQU0sSUFBSVgsRUFBRVksUUFBUTtZQUM5QkMsVUFBVWIsRUFBRWEsUUFBUTtZQUNwQkMsZUFBZVAsUUFBUVEsU0FBUyxDQUFDSixNQUFNLElBQUlLO1lBQzNDQyxnQkFBZ0JWLFFBQVFRLFNBQVMsQ0FBQ0UsY0FBYztRQUNsRDtRQUVBLHVCQUF1QjtRQUN2QixJQUFJQyxNQUNGbEIsRUFBRW1CLFdBQVcsSUFBSW5CLEVBQUVtQixXQUFXLENBQUNELEdBQUcsR0FDOUJsQixFQUFFbUIsV0FBVyxDQUFDRCxHQUFHLENBQUNFLElBQUksQ0FBQ3BCLEVBQUVtQixXQUFXLElBQ3BDRSxLQUFLSCxHQUFHO1FBRWQ7Ozs7O0tBS0MsR0FDRCxTQUFTSSxtQkFBbUJDLFNBQVM7WUFDbkMsSUFBSUMsb0JBQW9CO2dCQUFDO2dCQUFTO2dCQUFZO2FBQVE7WUFFdEQsT0FBTyxJQUFJQyxPQUFPRCxrQkFBa0JFLElBQUksQ0FBQyxNQUFNQyxJQUFJLENBQUNKO1FBQ3REO1FBRUE7Ozs7S0FJQyxHQUNELElBQUlLLHFCQUFxQk4sbUJBQW1CdEIsRUFBRTZCLFNBQVMsQ0FBQ04sU0FBUyxJQUFJLElBQUk7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LElBQUk7d0JBQ3RCQyxLQUFLRyxZQUFZSCxHQUFHO3dCQUNwQnpDLFVBQVU7b0JBQ1o7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLDZCQUE2QjtnQkFDN0J6QyxFQUFFYSxRQUFRLENBQUM7b0JBQ1RvRSxNQUFNTSxZQUFZTixJQUFJO29CQUN0QkMsS0FBS0ssWUFBWUwsR0FBRztvQkFDcEJ6QyxVQUFVO2dCQUNaO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSSxJQUFpRCxFQUFhO1FBQ2hFLFdBQVc7UUFDWGlELE9BQU9ELE9BQU8sR0FBRztZQUFFMUYsVUFBVUE7UUFBUztJQUN4QyxPQUFPLEVBR047QUFFSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NvZGVfY3ViaWNsZV8zLy4vbm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcz9mZTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIHNtb290aHNjcm9sbCB2MC40LjQgLSAyMDE5IC0gRHVzdGFuIEthc3RlbiwgSmVyZW1pYXMgTWVuaWNoZWxsaSAtIE1JVCBMaWNlbnNlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gYWxpYXNlc1xuICAgIHZhciB3ID0gd2luZG93O1xuICAgIHZhciBkID0gZG9jdW1lbnQ7XG5cbiAgICAvLyByZXR1cm4gaWYgc2Nyb2xsIGJlaGF2aW9yIGlzIHN1cHBvcnRlZCBhbmQgcG9seWZpbGwgaXMgbm90IGZvcmNlZFxuICAgIGlmIChcbiAgICAgICdzY3JvbGxCZWhhdmlvcicgaW4gZC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiZcbiAgICAgIHcuX19mb3JjZVNtb290aFNjcm9sbFBvbHlmaWxsX18gIT09IHRydWVcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnbG9iYWxzXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvLyBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbGVtZW50U2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgIHZhciBub3cgPVxuICAgICAgdy5wZXJmb3JtYW5jZSAmJiB3LnBlcmZvcm1hbmNlLm5vd1xuICAgICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSlcbiAgICAgICAgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgbWFkZSBieSBNaWNyb3NvZnRcbiAgICAgKiBAbWV0aG9kIGlzTWljcm9zb2Z0QnJvd3NlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyQWdlbnRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01pY3Jvc29mdEJyb3dzZXIodXNlckFnZW50KSB7XG4gICAgICB2YXIgdXNlckFnZW50UGF0dGVybnMgPSBbJ01TSUUgJywgJ1RyaWRlbnQvJywgJ0VkZ2UvJ107XG5cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVzZXJBZ2VudFBhdHRlcm5zLmpvaW4oJ3wnKSkudGVzdCh1c2VyQWdlbnQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSUUgaGFzIHJvdW5kaW5nIGJ1ZyByb3VuZGluZyBkb3duIGNsaWVudEhlaWdodCBhbmQgY2xpZW50V2lkdGggYW5kXG4gICAgICogcm91bmRpbmcgdXAgc2Nyb2xsSGVpZ2h0IGFuZCBzY3JvbGxXaWR0aCBjYXVzaW5nIGZhbHNlIHBvc2l0aXZlc1xuICAgICAqIG9uIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqL1xuICAgIHZhciBST1VORElOR19UT0xFUkFOQ0UgPSBpc01pY3Jvc29mdEJyb3dzZXIody5uYXZpZ2F0b3IudXNlckFnZW50KSA/IDEgOiAwO1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY3JvbGxFbGVtZW50KHgsIHkpIHtcbiAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICB0aGlzLnNjcm9sbFRvcCA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyByZXN1bHQgb2YgYXBwbHlpbmcgZWFzZSBtYXRoIGZ1bmN0aW9uIHRvIGEgbnVtYmVyXG4gICAgICogQG1ldGhvZCBlYXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhc2Uoaykge1xuICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSBzbW9vdGggYmVoYXZpb3Igc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKiBAbWV0aG9kIHNob3VsZEJhaWxPdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGZpcnN0QXJnXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dChmaXJzdEFyZykge1xuICAgICAgaWYgKFxuICAgICAgICBmaXJzdEFyZyA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgZmlyc3RBcmcgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdhdXRvJyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ2luc3RhbnQnXG4gICAgICApIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnb2JqZWN0JyAmJiBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IGFuZCBiZWhhdmlvciBpcyBzbW9vdGhcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvciB3aGVuIGJlaGF2aW9yIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdiZWhhdmlvciBtZW1iZXIgb2YgU2Nyb2xsT3B0aW9ucyAnICtcbiAgICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciArXG4gICAgICAgICAgJyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZW51bWVyYXRpb24gU2Nyb2xsQmVoYXZpb3IuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgc2Nyb2xsYWJsZSBzcGFjZSBpbiB0aGUgcHJvdmlkZWQgYXhpc1xuICAgICAqIEBtZXRob2QgaGFzU2Nyb2xsYWJsZVNwYWNlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PT0gJ1knKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRIZWlnaHQgKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzID09PSAnWCcpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsaWVudFdpZHRoICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIGEgc2Nyb2xsYWJsZSBvdmVyZmxvdyBwcm9wZXJ0eSBpbiB0aGUgYXhpc1xuICAgICAqIEBtZXRob2QgY2FuT3ZlcmZsb3dcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5PdmVyZmxvdyhlbCwgYXhpcykge1xuICAgICAgdmFyIG92ZXJmbG93VmFsdWUgPSB3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpWydvdmVyZmxvdycgKyBheGlzXTtcblxuICAgICAgcmV0dXJuIG92ZXJmbG93VmFsdWUgPT09ICdhdXRvJyB8fCBvdmVyZmxvd1ZhbHVlID09PSAnc2Nyb2xsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBjYW4gYmUgc2Nyb2xsZWQgaW4gZWl0aGVyIGF4aXNcbiAgICAgKiBAbWV0aG9kIGlzU2Nyb2xsYWJsZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbCkge1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVkgPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdZJykgJiYgY2FuT3ZlcmZsb3coZWwsICdZJyk7XG4gICAgICB2YXIgaXNTY3JvbGxhYmxlWCA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1gnKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1gnKTtcblxuICAgICAgcmV0dXJuIGlzU2Nyb2xsYWJsZVkgfHwgaXNTY3JvbGxhYmxlWDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsICE9PSBkLmJvZHkgJiYgaXNTY3JvbGxhYmxlKGVsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlIHx8IGVsLmhvc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcbiAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgY3VycmVudFg7XG4gICAgICB2YXIgY3VycmVudFk7XG4gICAgICB2YXIgZWxhcHNlZCA9ICh0aW1lIC0gY29udGV4dC5zdGFydFRpbWUpIC8gU0NST0xMX1RJTUU7XG5cbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICAgICAgdmFsdWUgPSBlYXNlKGVsYXBzZWQpO1xuXG4gICAgICBjdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgICAgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcblxuICAgICAgY29udGV4dC5tZXRob2QuY2FsbChjb250ZXh0LnNjcm9sbGFibGUsIGN1cnJlbnRYLCBjdXJyZW50WSk7XG5cbiAgICAgIC8vIHNjcm9sbCBtb3JlIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgb3VyIGRlc3RpbmF0aW9uXG4gICAgICBpZiAoY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjdXJyZW50WSAhPT0gY29udGV4dC55KSB7XG4gICAgICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAuYmluZCh3LCBjb250ZXh0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xscyB3aW5kb3cgb3IgZWxlbWVudCB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgIC8vIHcuc2Nyb2xsIGFuZCB3LnNjcm9sbFRvXG4gICAgdy5zY3JvbGwgPSB3LnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBpZiBwcmVzZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFlcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyB3LnNjcm9sbEJ5XG4gICAgdy5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyBhcmd1bWVudHNbMF0gOiAwLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0ubGVmdCArICh3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcCArICh3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCBhbmQgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgPSBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgb25lIG51bWJlciBpcyBwYXNzZWQsIHRocm93IGVycm9yIHRvIG1hdGNoIEZpcmVmb3ggaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdWYWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbC5lbGVtZW50U2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAvLyB1c2UgbGVmdCBwcm9wLCBmaXJzdCBudW1iZXIgYXJndW1lbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsTGVmdFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JyA/IH5+YXJndW1lbnRzWzBdIDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIC8vIHVzZSB0b3AgcHJvcCwgc2Vjb25kIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFRvcFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyB+fmFyZ3VtZW50c1sxXSA6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbExlZnQgOiB+fmxlZnQsXG4gICAgICAgIHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxUb3AgOiB+fnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0XG4gICAgICAgICAgICA6IH5+YXJndW1lbnRzWzBdICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1sxXSArIHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbCh7XG4gICAgICAgIGxlZnQ6IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgIGJlaGF2aW9yOiBhcmd1bWVudHNbMF0uYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEludG9WaWV3LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50ID0gZmluZFNjcm9sbGFibGVQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFJlY3RzID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbnNpZGUgcGFyZW50XG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCArIGNsaWVudFJlY3RzLnRvcCAtIHBhcmVudFJlY3RzLnRvcFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldmVhbCBwYXJlbnQgaW4gdmlld3BvcnQgdW5sZXNzIGlzIGZpeGVkXG4gICAgICAgIGlmICh3LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsYWJsZVBhcmVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICAgIGxlZnQ6IHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgICB0b3A6IHBhcmVudFJlY3RzLnRvcCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogY2xpZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNvbW1vbmpzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IHBvbHlmaWxsOiBwb2x5ZmlsbCB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGdsb2JhbFxuICAgIHBvbHlmaWxsKCk7XG4gIH1cblxufSgpKTtcbiJdLCJuYW1lcyI6WyJwb2x5ZmlsbCIsInciLCJ3aW5kb3ciLCJkIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIl9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fIiwiRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiU0NST0xMX1RJTUUiLCJvcmlnaW5hbCIsInNjcm9sbCIsInNjcm9sbFRvIiwic2Nyb2xsQnkiLCJlbGVtZW50U2Nyb2xsIiwicHJvdG90eXBlIiwic2Nyb2xsRWxlbWVudCIsInNjcm9sbEludG9WaWV3Iiwibm93IiwicGVyZm9ybWFuY2UiLCJiaW5kIiwiRGF0ZSIsImlzTWljcm9zb2Z0QnJvd3NlciIsInVzZXJBZ2VudCIsInVzZXJBZ2VudFBhdHRlcm5zIiwiUmVnRXhwIiwiam9pbiIsInRlc3QiLCJST1VORElOR19UT0xFUkFOQ0UiLCJuYXZpZ2F0b3IiLCJ4IiwieSIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJlYXNlIiwiayIsIk1hdGgiLCJjb3MiLCJQSSIsInNob3VsZEJhaWxPdXQiLCJmaXJzdEFyZyIsImJlaGF2aW9yIiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiaGFzU2Nyb2xsYWJsZVNwYWNlIiwiZWwiLCJheGlzIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJzY3JvbGxXaWR0aCIsImNhbk92ZXJmbG93Iiwib3ZlcmZsb3dWYWx1ZSIsImdldENvbXB1dGVkU3R5bGUiLCJpc1Njcm9sbGFibGUiLCJpc1Njcm9sbGFibGVZIiwiaXNTY3JvbGxhYmxlWCIsImZpbmRTY3JvbGxhYmxlUGFyZW50IiwiYm9keSIsInBhcmVudE5vZGUiLCJob3N0Iiwic3RlcCIsImNvbnRleHQiLCJ0aW1lIiwidmFsdWUiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwiZWxhcHNlZCIsInN0YXJ0VGltZSIsInN0YXJ0WCIsInN0YXJ0WSIsIm1ldGhvZCIsImNhbGwiLCJzY3JvbGxhYmxlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic21vb3RoU2Nyb2xsIiwic2Nyb2xsWCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0IiwiYXJndW1lbnRzIiwibGVmdCIsInRvcCIsIlN5bnRheEVycm9yIiwic2Nyb2xsYWJsZVBhcmVudCIsInBhcmVudFJlY3RzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50UmVjdHMiLCJwb3NpdGlvbiIsImV4cG9ydHMiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js\n");

/***/ })

};
;