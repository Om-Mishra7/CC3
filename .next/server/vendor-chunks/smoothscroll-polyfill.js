/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smoothscroll-polyfill";
exports.ids = ["vendor-chunks/smoothscroll-polyfill"];
exports.modules = {

/***/ "(ssr)/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/smoothscroll-polyfill/dist/smoothscroll.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("/* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */ (function() {\n    \"use strict\";\n    // polyfill\n    function polyfill() {\n        // aliases\n        var w = window;\n        var d = document;\n        // return if scroll behavior is supported and polyfill is not forced\n        if (\"scrollBehavior\" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n            return;\n        }\n        // globals\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468;\n        // object gathering original scroll methods\n        var original = {\n            scroll: w.scroll || w.scrollTo,\n            scrollBy: w.scrollBy,\n            elementScroll: Element.prototype.scroll || scrollElement,\n            scrollIntoView: Element.prototype.scrollIntoView\n        };\n        // define timing method\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n     * indicates if a the current browser is made by Microsoft\n     * @method isMicrosoftBrowser\n     * @param {String} userAgent\n     * @returns {Boolean}\n     */ function isMicrosoftBrowser(userAgent) {\n            var userAgentPatterns = [\n                \"MSIE \",\n                \"Trident/\",\n                \"Edge/\"\n            ];\n            return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\n        }\n        /*\n     * IE has rounding bug rounding down clientHeight and clientWidth and\n     * rounding up scrollHeight and scrollWidth causing false positives\n     * on hasScrollableSpace\n     */ var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */ function scrollElement(x, y) {\n            this.scrollLeft = x;\n            this.scrollTop = y;\n        }\n        /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */ function ease(k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} firstArg\n     * @returns {Boolean}\n     */ function shouldBailOut(firstArg) {\n            if (firstArg === null || typeof firstArg !== \"object\" || firstArg.behavior === undefined || firstArg.behavior === \"auto\" || firstArg.behavior === \"instant\") {\n                // first argument is not an object/null\n                // or behavior is auto, instant or undefined\n                return true;\n            }\n            if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\n                // first argument is an object and behavior is smooth\n                return false;\n            }\n            // throw error when behavior is not supported\n            throw new TypeError(\"behavior member of ScrollOptions \" + firstArg.behavior + \" is not a valid value for enumeration ScrollBehavior.\");\n        }\n        /**\n     * indicates if an element has scrollable space in the provided axis\n     * @method hasScrollableSpace\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function hasScrollableSpace(el, axis) {\n            if (axis === \"Y\") {\n                return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n            }\n            if (axis === \"X\") {\n                return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n            }\n        }\n        /**\n     * indicates if an element has a scrollable overflow property in the axis\n     * @method canOverflow\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function canOverflow(el, axis) {\n            var overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\n            return overflowValue === \"auto\" || overflowValue === \"scroll\";\n        }\n        /**\n     * indicates if an element can be scrolled in either axis\n     * @method isScrollable\n     * @param {Node} el\n     * @param {String} axis\n     * @returns {Boolean}\n     */ function isScrollable(el) {\n            var isScrollableY = hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\n            var isScrollableX = hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\n            return isScrollableY || isScrollableX;\n        }\n        /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */ function findScrollableParent(el) {\n            while(el !== d.body && isScrollable(el) === false){\n                el = el.parentNode || el.host;\n            }\n            return el;\n        }\n        /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     * @returns {undefined}\n     */ function step(context) {\n            var time = now();\n            var value;\n            var currentX;\n            var currentY;\n            var elapsed = (time - context.startTime) / SCROLL_TIME;\n            // avoid elapsed times higher than one\n            elapsed = elapsed > 1 ? 1 : elapsed;\n            // apply easing to elapsed time\n            value = ease(elapsed);\n            currentX = context.startX + (context.x - context.startX) * value;\n            currentY = context.startY + (context.y - context.startY) * value;\n            context.method.call(context.scrollable, currentX, currentY);\n            // scroll more if we have not reached our destination\n            if (currentX !== context.x || currentY !== context.y) {\n                w.requestAnimationFrame(step.bind(w, context));\n            }\n        }\n        /**\n     * scrolls window or element with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {undefined}\n     */ function smoothScroll(el, x, y) {\n            var scrollable;\n            var startX;\n            var startY;\n            var method;\n            var startTime = now();\n            // define scroll context\n            if (el === d.body) {\n                scrollable = w;\n                startX = w.scrollX || w.pageXOffset;\n                startY = w.scrollY || w.pageYOffset;\n                method = original.scroll;\n            } else {\n                scrollable = el;\n                startX = el.scrollLeft;\n                startY = el.scrollTop;\n                method = scrollElement;\n            }\n            // scroll looping over a frame\n            step({\n                scrollable: scrollable,\n                method: method,\n                startTime: startTime,\n                startX: startX,\n                startY: startY,\n                x: x,\n                y: y\n            });\n        }\n        // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n        w.scroll = w.scrollTo = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : w.scrollX || w.pageXOffset, // use top prop, second argument if present or fallback to scrollY\n                arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n                return;\n            }\n            // LET THE SMOOTHNESS BEGIN!\n            smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        };\n        // w.scrollBy\n        w.scrollBy = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0])) {\n                original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n                return;\n            }\n            // LET THE SMOOTHNESS BEGIN!\n            smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        };\n        // Element.prototype.scroll and Element.prototype.scrollTo\n        Element.prototype.scroll = Element.prototype.scrollTo = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                // if one number is passed, throw error to match Firefox implementation\n                if (typeof arguments[0] === \"number\" && arguments[1] === undefined) {\n                    throw new SyntaxError(\"Value could not be converted\");\n                }\n                original.elementScroll.call(this, // use left prop, first number argument or fallback to scrollLeft\n                arguments[0].left !== undefined ? ~~arguments[0].left : typeof arguments[0] !== \"object\" ? ~~arguments[0] : this.scrollLeft, // use top prop, second argument or fallback to scrollTop\n                arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n                return;\n            }\n            var left = arguments[0].left;\n            var top = arguments[0].top;\n            // LET THE SMOOTHNESS BEGIN!\n            smoothScroll.call(this, this, typeof left === \"undefined\" ? this.scrollLeft : ~~left, typeof top === \"undefined\" ? this.scrollTop : ~~top);\n        };\n        // Element.prototype.scrollBy\n        Element.prototype.scrollBy = function() {\n            // avoid action when no arguments are passed\n            if (arguments[0] === undefined) {\n                return;\n            }\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n                return;\n            }\n            this.scroll({\n                left: ~~arguments[0].left + this.scrollLeft,\n                top: ~~arguments[0].top + this.scrollTop,\n                behavior: arguments[0].behavior\n            });\n        };\n        // Element.prototype.scrollIntoView\n        Element.prototype.scrollIntoView = function() {\n            // avoid smooth behavior if not required\n            if (shouldBailOut(arguments[0]) === true) {\n                original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n                return;\n            }\n            // LET THE SMOOTHNESS BEGIN!\n            var scrollableParent = findScrollableParent(this);\n            var parentRects = scrollableParent.getBoundingClientRect();\n            var clientRects = this.getBoundingClientRect();\n            if (scrollableParent !== d.body) {\n                // reveal element inside parent\n                smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top);\n                // reveal parent in viewport unless is fixed\n                if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\n                    w.scrollBy({\n                        left: parentRects.left,\n                        top: parentRects.top,\n                        behavior: \"smooth\"\n                    });\n                }\n            } else {\n                // reveal element in viewport\n                w.scrollBy({\n                    left: clientRects.left,\n                    top: clientRects.top,\n                    behavior: \"smooth\"\n                });\n            }\n        };\n    }\n    if (true) {\n        // commonjs\n        module.exports = {\n            polyfill: polyfill\n        };\n    } else {}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRixHQUNoRjtJQUNDO0lBRUEsV0FBVztJQUNYLFNBQVNBO1FBQ1AsVUFBVTtRQUNWLElBQUlDLElBQUlDO1FBQ1IsSUFBSUMsSUFBSUM7UUFFUixvRUFBb0U7UUFDcEUsSUFDRSxvQkFBb0JELEVBQUVFLGVBQWUsQ0FBQ0MsS0FBSyxJQUMzQ0wsRUFBRU0sNkJBQTZCLEtBQUssTUFDcEM7WUFDQTtRQUNGO1FBRUEsVUFBVTtRQUNWLElBQUlDLFVBQVVQLEVBQUVRLFdBQVcsSUFBSVIsRUFBRU8sT0FBTztRQUN4QyxJQUFJRSxjQUFjO1FBRWxCLDJDQUEyQztRQUMzQyxJQUFJQyxXQUFXO1lBQ2JDLFFBQVFYLEVBQUVXLE1BQU0sSUFBSVgsRUFBRVksUUFBUTtZQUM5QkMsVUFBVWIsRUFBRWEsUUFBUTtZQUNwQkMsZUFBZVAsUUFBUVEsU0FBUyxDQUFDSixNQUFNLElBQUlLO1lBQzNDQyxnQkFBZ0JWLFFBQVFRLFNBQVMsQ0FBQ0UsY0FBYztRQUNsRDtRQUVBLHVCQUF1QjtRQUN2QixJQUFJQyxNQUNGbEIsRUFBRW1CLFdBQVcsSUFBSW5CLEVBQUVtQixXQUFXLENBQUNELEdBQUcsR0FDOUJsQixFQUFFbUIsV0FBVyxDQUFDRCxHQUFHLENBQUNFLElBQUksQ0FBQ3BCLEVBQUVtQixXQUFXLElBQ3BDRSxLQUFLSCxHQUFHO1FBRWQ7Ozs7O0tBS0MsR0FDRCxTQUFTSSxtQkFBbUJDLFNBQVM7WUFDbkMsSUFBSUMsb0JBQW9CO2dCQUFDO2dCQUFTO2dCQUFZO2FBQVE7WUFFdEQsT0FBTyxJQUFJQyxPQUFPRCxrQkFBa0JFLElBQUksQ0FBQyxNQUFNQyxJQUFJLENBQUNKO1FBQ3REO1FBRUE7Ozs7S0FJQyxHQUNELElBQUlLLHFCQUFxQk4sbUJBQW1CdEIsRUFBRTZCLFNBQVMsQ0FBQ04sU0FBUyxJQUFJLElBQUk7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LElBQUk7d0JBQ3RCQyxLQUFLRyxZQUFZSCxHQUFHO3dCQUNwQnpDLFVBQVU7b0JBQ1o7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLDZCQUE2QjtnQkFDN0J6QyxFQUFFYSxRQUFRLENBQUM7b0JBQ1RvRSxNQUFNTSxZQUFZTixJQUFJO29CQUN0QkMsS0FBS0ssWUFBWUwsR0FBRztvQkFDcEJ6QyxVQUFVO2dCQUNaO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSSxJQUFpRCxFQUFhO1FBQ2hFLFdBQVc7UUFDWGlELE9BQU9ELE9BQU8sR0FBRztZQUFFMUYsVUFBVUE7UUFBUztJQUN4QyxPQUFPLEVBR047QUFFSCIsInNvdXJjZXMiOlsid2VicGFjazovL2R1aGFja3NfMy8uL25vZGVfbW9kdWxlcy9zbW9vdGhzY3JvbGwtcG9seWZpbGwvZGlzdC9zbW9vdGhzY3JvbGwuanM/ZmUwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBzbW9vdGhzY3JvbGwgdjAuNC40IC0gMjAxOSAtIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIGFsaWFzZXNcbiAgICB2YXIgdyA9IHdpbmRvdztcbiAgICB2YXIgZCA9IGRvY3VtZW50O1xuXG4gICAgLy8gcmV0dXJuIGlmIHNjcm9sbCBiZWhhdmlvciBpcyBzdXBwb3J0ZWQgYW5kIHBvbHlmaWxsIGlzIG5vdCBmb3JjZWRcbiAgICBpZiAoXG4gICAgICAnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmXG4gICAgICB3Ll9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fICE9PSB0cnVlXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2xvYmFsc1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLy8gb2JqZWN0IGdhdGhlcmluZyBvcmlnaW5hbCBzY3JvbGwgbWV0aG9kc1xuICAgIHZhciBvcmlnaW5hbCA9IHtcbiAgICAgIHNjcm9sbDogdy5zY3JvbGwgfHwgdy5zY3JvbGxUbyxcbiAgICAgIHNjcm9sbEJ5OiB3LnNjcm9sbEJ5LFxuICAgICAgZWxlbWVudFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLy8gZGVmaW5lIHRpbWluZyBtZXRob2RcbiAgICB2YXIgbm93ID1cbiAgICAgIHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgICAgPyB3LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHcucGVyZm9ybWFuY2UpXG4gICAgICAgIDogRGF0ZS5ub3c7XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSB0aGUgY3VycmVudCBicm93c2VyIGlzIG1hZGUgYnkgTWljcm9zb2Z0XG4gICAgICogQG1ldGhvZCBpc01pY3Jvc29mdEJyb3dzZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlckFnZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNaWNyb3NvZnRCcm93c2VyKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVzZXJBZ2VudFBhdHRlcm5zID0gWydNU0lFICcsICdUcmlkZW50LycsICdFZGdlLyddO1xuXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1c2VyQWdlbnRQYXR0ZXJucy5qb2luKCd8JykpLnRlc3QodXNlckFnZW50KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIElFIGhhcyByb3VuZGluZyBidWcgcm91bmRpbmcgZG93biBjbGllbnRIZWlnaHQgYW5kIGNsaWVudFdpZHRoIGFuZFxuICAgICAqIHJvdW5kaW5nIHVwIHNjcm9sbEhlaWdodCBhbmQgc2Nyb2xsV2lkdGggY2F1c2luZyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgKiBvbiBoYXNTY3JvbGxhYmxlU3BhY2VcbiAgICAgKi9cbiAgICB2YXIgUk9VTkRJTkdfVE9MRVJBTkNFID0gaXNNaWNyb3NvZnRCcm93c2VyKHcubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAxIDogMDtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBmaXJzdEFyZ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoZmlyc3RBcmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZmlyc3RBcmcgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGZpcnN0QXJnICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnYXV0bycgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdpbnN0YW50J1xuICAgICAgKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QvbnVsbFxuICAgICAgICAvLyBvciBiZWhhdmlvciBpcyBhdXRvLCBpbnN0YW50IG9yIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcgJiYgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnYmVoYXZpb3IgbWVtYmVyIG9mIFNjcm9sbE9wdGlvbnMgJyArXG4gICAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgK1xuICAgICAgICAgICcgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGVudW1lcmF0aW9uIFNjcm9sbEJlaGF2aW9yLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgc3BhY2UgaW4gdGhlIHByb3ZpZGVkIGF4aXNcbiAgICAgKiBAbWV0aG9kIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbGFibGVTcGFjZShlbCwgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT09ICdZJykge1xuICAgICAgICByZXR1cm4gZWwuY2xpZW50SGVpZ2h0ICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyA9PT0gJ1gnKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRXaWR0aCArIFJPVU5ESU5HX1RPTEVSQU5DRSA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGhhcyBhIHNjcm9sbGFibGUgb3ZlcmZsb3cgcHJvcGVydHkgaW4gdGhlIGF4aXNcbiAgICAgKiBAbWV0aG9kIGNhbk92ZXJmbG93XG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuT3ZlcmZsb3coZWwsIGF4aXMpIHtcbiAgICAgIHZhciBvdmVyZmxvd1ZhbHVlID0gdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKVsnb3ZlcmZsb3cnICsgYXhpc107XG5cbiAgICAgIHJldHVybiBvdmVyZmxvd1ZhbHVlID09PSAnYXV0bycgfHwgb3ZlcmZsb3dWYWx1ZSA9PT0gJ3Njcm9sbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgY2FuIGJlIHNjcm9sbGVkIGluIGVpdGhlciBheGlzXG4gICAgICogQG1ldGhvZCBpc1Njcm9sbGFibGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwpIHtcbiAgICAgIHZhciBpc1Njcm9sbGFibGVZID0gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCAnWScpICYmIGNhbk92ZXJmbG93KGVsLCAnWScpO1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVggPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdYJykgJiYgY2FuT3ZlcmZsb3coZWwsICdYJyk7XG5cbiAgICAgIHJldHVybiBpc1Njcm9sbGFibGVZIHx8IGlzU2Nyb2xsYWJsZVg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHdoaWxlIChlbCAhPT0gZC5ib2R5ICYmIGlzU2Nyb2xsYWJsZShlbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZSB8fCBlbC5ob3N0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IG9yIGVsZW1lbnQgd2l0aCBhIHNtb290aCBiZWhhdmlvclxuICAgICAqIEBtZXRob2Qgc21vb3RoU2Nyb2xsXG4gICAgICogQHBhcmFtIHtPYmplY3R8Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT1JJR0lOQUwgTUVUSE9EUyBPVkVSUklERVNcbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgICAgLy8gdXNlIHRvcCBwcm9wLCBzZWNvbmQgYXJndW1lbnQgaWYgcHJlc2VudCBvciBmYWxsYmFjayB0byBzY3JvbGxZXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnID8gYXJndW1lbnRzWzBdIDogMCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDBcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIG9uZSBudW1iZXIgaXMgcGFzc2VkLCB0aHJvdyBlcnJvciB0byBtYXRjaCBGaXJlZm94IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLy8gdXNlIGxlZnQgcHJvcCwgZmlyc3QgbnVtYmVyIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbExlZnRcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyB+fmFyZ3VtZW50c1swXSA6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBvciBmYWxsYmFjayB0byBzY3JvbGxUb3BcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gfn5hcmd1bWVudHNbMV0gOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSBhcmd1bWVudHNbMF0ubGVmdDtcbiAgICAgIHZhciB0b3AgPSBhcmd1bWVudHNbMF0udG9wO1xuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxMZWZ0IDogfn5sZWZ0LFxuICAgICAgICB0eXBlb2YgdG9wID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsVG9wIDogfn50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdCArIHRoaXMuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1swXSArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMV0gKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICBsZWZ0OiB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IH5+YXJndW1lbnRzWzBdLnRvcCArIHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICBiZWhhdmlvcjogYXJndW1lbnRzWzBdLmJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxJbnRvVmlldy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZXZlYWwgcGFyZW50IGluIHZpZXdwb3J0IHVubGVzcyBpcyBmaXhlZFxuICAgICAgICBpZiAody5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGFibGVQYXJlbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwYXJlbnRSZWN0cy50b3AsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogY2xpZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjb21tb25qc1xuICAgIG1vZHVsZS5leHBvcnRzID0geyBwb2x5ZmlsbDogcG9seWZpbGwgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnbG9iYWxcbiAgICBwb2x5ZmlsbCgpO1xuICB9XG5cbn0oKSk7XG4iXSwibmFtZXMiOlsicG9seWZpbGwiLCJ3Iiwid2luZG93IiwiZCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJfX2ZvcmNlU21vb3RoU2Nyb2xsUG9seWZpbGxfXyIsIkVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIlNDUk9MTF9USU1FIiwib3JpZ2luYWwiLCJzY3JvbGwiLCJzY3JvbGxUbyIsInNjcm9sbEJ5IiwiZWxlbWVudFNjcm9sbCIsInByb3RvdHlwZSIsInNjcm9sbEVsZW1lbnQiLCJzY3JvbGxJbnRvVmlldyIsIm5vdyIsInBlcmZvcm1hbmNlIiwiYmluZCIsIkRhdGUiLCJpc01pY3Jvc29mdEJyb3dzZXIiLCJ1c2VyQWdlbnQiLCJ1c2VyQWdlbnRQYXR0ZXJucyIsIlJlZ0V4cCIsImpvaW4iLCJ0ZXN0IiwiUk9VTkRJTkdfVE9MRVJBTkNFIiwibmF2aWdhdG9yIiwieCIsInkiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiZWFzZSIsImsiLCJNYXRoIiwiY29zIiwiUEkiLCJzaG91bGRCYWlsT3V0IiwiZmlyc3RBcmciLCJiZWhhdmlvciIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsImhhc1Njcm9sbGFibGVTcGFjZSIsImVsIiwiYXhpcyIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsImNsaWVudFdpZHRoIiwic2Nyb2xsV2lkdGgiLCJjYW5PdmVyZmxvdyIsIm92ZXJmbG93VmFsdWUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNTY3JvbGxhYmxlIiwiaXNTY3JvbGxhYmxlWSIsImlzU2Nyb2xsYWJsZVgiLCJmaW5kU2Nyb2xsYWJsZVBhcmVudCIsImJvZHkiLCJwYXJlbnROb2RlIiwiaG9zdCIsInN0ZXAiLCJjb250ZXh0IiwidGltZSIsInZhbHVlIiwiY3VycmVudFgiLCJjdXJyZW50WSIsImVsYXBzZWQiLCJzdGFydFRpbWUiLCJzdGFydFgiLCJzdGFydFkiLCJtZXRob2QiLCJjYWxsIiwic2Nyb2xsYWJsZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNtb290aFNjcm9sbCIsInNjcm9sbFgiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsImFyZ3VtZW50cyIsImxlZnQiLCJ0b3AiLCJTeW50YXhFcnJvciIsInNjcm9sbGFibGVQYXJlbnQiLCJwYXJlbnRSZWN0cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFJlY3RzIiwicG9zaXRpb24iLCJleHBvcnRzIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js\n");

/***/ })

};
;